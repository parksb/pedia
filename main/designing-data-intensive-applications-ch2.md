# Part 2. 분산 데이터

## 복제

* 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미.
  * 데이터와 사용자의 거리를 지리적으로 가깝게 만들어 지연 시간을 줄인다.
  * 시스템 일부에 장애가 발생해도 지속적으로 동작할 수 있게 만들어 가용성을 높인다.
  * 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 높인다.
* 복제의 어려움은 복제된 데이터의 변경에 있다.

### 리더와 팔로워

* 데이터베이스의 복사본을 저장하는 각 노드를 레플리카(replica)라고 한다.
* 데이터 일관성 문제에 대한 일반적인 해결책은 리더 기반 복제다.
  ![리더 기반 복제](https://user-images.githubusercontent.com/6410412/67636527-db92bd80-f914-11e9-8ab4-51f9c86b29dd.png)
  * 레플리카 중 하나를 리더로 지정한다. 클라이언트가 데이터를 변경하려면 리더에게 요청을 보낸다.
  * 또 다른 레플리카는 팔로워로 지정한다.  리더는 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그의 일부로 팔로워에게 전송한다.
  * 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 업데이트를 적용해 로컬 복사본을 갱신한다.

#### 동기식 대 비동기식 복제

* 복제 시스템의 가장 중요한 세부 사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부다.
* 동기식: 리더는 팔로워가 쓰기를 수신했는지 응답할 때까지 기다린다. 응답이 오면 사용자에게 성공을 응답하고, 다른 클라이언트에게 해당 쓰기를 보여준다.
* 비동기식: 리더가 팔로워에게 메시지를 전송하지만 응답을 기다리지 않는다.
* 보통 리더 기반 복제는 완전히 비동기식으로 구성한다.
  * 동기식 복제는 팔로워 사이의 일관성을 보장한다.
  * 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.
  * 하지만 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있다.

#### 노드 중단 처리

* 시스템의 모든 노드는 장애로 인해 예기치 않게 중단될 수 있지만, 유지보수로 인해 중단될 수도 있다.
* 팔로워 장애: 각 팔로워는 수신한 데이터 변경 로그를 로컬 디스크에 보관한다. 팔로워가 중단되어 재시작하는 경우, 팔로워는 변경 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다. 그러면 리더와 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있다.
* 리더 장애: 리더가 죽으면 팔로워 중 하나를 리더로 승격해야 하며, 클라이어트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하다. 또한 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비해야 한다. 이 과정을 장애 복구라 한다.

### 복제 지연 문제

* 리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만, 읽기 전용 질의는 어떤 복제 서버에서도 가능하다.
* 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 업데이트되지 않은 오래된 정보를 볼 수도 있다. 이런 불일치는 일시적이다. 데이터베이스에 쓰기를 멈추고 잠기 기다리면 팔로워는 리더를 따라잡게 된다. 이런 효과를 최종적 일관성이라고 한다.
* 지연이 매우 크면 불일치 문제는 이론적인 문제가 아니라 실제 문제가 된다. 이를 위해 쓰기 후 읽기 일관성(read-after-write consistency)과 단조 읽기(monotonic read)가 필요하다.
