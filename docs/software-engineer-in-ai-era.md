# AI 시대의 소프트웨어 엔지니어

[[artificial-intelligence]]{AI} 시대에 소프트웨어 엔지니어라는 직업은 무슨 일을 하는가? AI의 소프트웨어 개발 능력에 따라 다를 것이다. AI에게 기대하는 최소는, 사람이 코드의 일부를 입력하면 코드 스니펫을 출력하는 능력이다. 이때 소프트웨어 엔지니어에게 AI는 자동완성 도구다. 이 수준은 이미 넘어섰다. AI에게 기대하는 최대는, 사람이 추상적인 비즈니스 요구사항을 입력하면 AI가 즉시 실행 가능한 프로그램을 출력하는 능력이다. 이 수준에서 코드는 완전한 블랙박스고, [[software-engineering]] 자체가 무의미하다. 아직 여기에는 도달하지 않았다.

최대의 수준에 도달하려면 AI가 출력한 프로그램의 첫 버전이 모든 요구사항을 올바르게 처리할 수 있어야 한다. 만에 하나 엣지 케이스를 처리하지 못한 경우에도 AI가 즉시 컨텍스트를 파악해 수정할 수 있어야 한다. 만약 AI가 스스로 컨텍스트를 파악하지 못한다면, 어떤 동작으로 인해 무슨 문제가 생기는지 파악하는 것은 사람의 몫이 된다. 즉, 사람이 소프트웨어를 유지보수, 운영해야 한다. 사람이 병목이 되는 순간 수정의 비용은 급격히 늘어난다. AI가 소프트웨어를 수정하는 비용은 소프트웨어 엔지니어가 프로그램을 수정하는 비용보다 낮아야 한다.

많은 이들이 AI의 최대 수준을 상상한다. 지금은 불가능하지만, 언젠가는 가능할 것으로 기대한다. 따라서 'AI 시대'에 대해 이야기할 때는 최대 수준을 달성한 상황을 상정해야 한다.

## AI 사용 패턴 기록

이런 시대에는 아무나 그럴듯한 예언을 할 수 있다. 예언을 하고 싶지는 않으니 나의 AI 사용 패턴을 기록해본다.

### 2024년 12월

[GitHub Copilot](https://github.com/features/copilot)으로 코드 스니펫을 자동 완성한다. 주석이나 함수 시그니처를 작성해두면 내용은 AI가 완성해준다. AI가 작성한 코드가 완전하지 않기 때문에 반드시 수정해야 한다. 대부분의 코드는 내가 작성한다. 

### 2025년 4월

[ChatGPT](https://chatgpt.com/)를 사용한다. 요구사항을 입력하면 AI가 코드를 제시한다. 이 코드를 실제로 사용하려면 내가 사용하는 에디터에 복사-붙여넣기해야 한다. 실수가 많고, 작동하지 않는 코드를 작성하기도 한다. 대부분의 코드를 AI가 작성하지만, 내가 컨텍스트를 일일이 설명해야 한다. AI의 실수를 고치는 것보다 내가 직접 구현하는 편이 빠르다.

### 2025년 5월

[Cursor](https://www.cursor.com/)와 [[zed-editor]] 같은 AI 에디터를 사용한다. 개발 요구 사항을 입력하면 AI가 코드베이스 전체를 탐색해 편집한다. 대부분의 코드를 AI가 작성하지만, 모든 변경사항을 내가 검토하고 승인한다. 내가 전체적인 구조를 설계하고, 스켈레톤 코드를 작성해두지 않으면 AI는 많은 실수를 한다.

### 2025년 8월

[Claude Code](https://claude.com/product/claude-code)를 사용한다. 기술적인 요구 사항을 추상적으로 입력하면 AI가 모든 코드베이스를 훑고, 각종 도구를 이용해 구체적인 기능을 구현한다. 많은 코드를 AI가 작성하지만, 초기에 내가 잘못된 설계를 입력하거나 AI가 잘못 접근해 구현하는 경우 초기 가정에서 벗어나지 못한다. 도구나 기능을 구현할 수 있지만, 한 번에 완벽히 구현하지는 못한다.

### 2026년 2월

여전히 [Claude Code](https://claude.com/product/claude-code)를 사용한다. 요구사항을 잘 정리해서 계획서를 작성하게 하고, 여러 번 그 계획을 검토하게 한다. 계획서 작성에 구현보다 훨씬 많은 시간을 쓴다. 문제 상황을 입력하면 설계부터 구현까지 AI가 담당한다. 슬랙 링크나 리니어 이슈 번호를 입력하면 AI가 스스로 맥락을 파악한다. 거의 모든 코드를 AI가 작성한다. 코드 품질은 그리 좋지 않은데, 애초에 코드 품질이 예전만큼 중요치 않다고 느낀다.

엣지 케이스나 잠재적인 위험에는 잘 대응하지 못한다. 이를 극복하기 위해 계획 단계에 반드시 계획의 각 부분을 실증하게 하고, [[test-driven-development-for-ai-coding]]을 한다. (다만 테스트도 AI가 작성한다.) 계획을 잘 작성하면 한 번에 구현이 끝나는 경우도 많다.

복잡한 워크플로우나 정책은 내가 많은 부분을 결정해야 하고, 나의 기술 이해가 완성도에 많은 영향을 미친다. 오래된 히스토리와 복잡한 맥락이 엮여 있으면 AI는 국소적인 해결책만 제시한다. 여러 조직에 걸친 의사 결정은 사람이 해야 한다. 예를 들어, 네이티브 모바일 앱이 웹뷰의 HTTP 요청을 가로채 헤더에 토큰을 주입하는 인증 방식으로 인해 웹뷰의 앞으로가기/뒤로가기 동작에 문제가 있는 경우, AI는 주어진 문제 해결에만 천착해 근본적인 대안을 제시하지 못한다.  사람은 기존의 토큰 인증 방식 대신 mTLS 인증 방식을 고려한다. 이 의사결정에는 앞으로가기/뒤로가기라는 현재 문제뿐만 아니라, 시스템 운영과 설계 측면에서의 장기적인 관점이 동기로 작용한다. 사람은 네이티브 앱, 웹뷰, 서버, 인프라 등 소프트웨어를 구성하는 모든 레이어에서 어떤 변경이 필요한지 계획한다.

## 관련문서

- [[artificial-intelligence]]
- [[google-prompt-engineering]]
- [[surviving-in-ai-era]]
- [[measuring-the-impact-of-early-2025-ai-on-experienced-open-source-developer-productivity]]
