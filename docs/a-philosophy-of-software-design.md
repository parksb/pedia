# A Philosophy of Software Design

### Example: storing text for an editor

GUI 텍스트 에디터를 만드는 예시를 살펴보자. 이 에디터는 파일을 보여주고, 사용자는 포인트, 클릭, 타이핑을 할 수 있다. 또한 같은 파일에 대해 동시에 여러 뷰를 제공해야 한다. 그리고 멀티레벨 undo와 redo를 지원해야 한다.

학생들은 이 프로젝트에서 파일의 텍스트를 관리하는 클래스를 만들었다. 텍스트 클래스는 파일을 메모리에 로딩하는 메서드와 텍스트를 읽는 메서드, 그리고 수정한 텍스트를 다시 파일에 쓰는 메서드가 있었다. 많은 팀이 특수목적의 API를 구현했다.

학생들은 이 클래스가 인터랙티브 에디터에 사용될 것임을 알았다. 때문에 텍스트 클래스의 API가 특정 기능을 제공해야 한다고 생각한 것이다. 예를 들어, 사용자가 백스페이스 키를 누른다면 에디터는 커서 왼쪽의 문자를 즉시 지울 것이다. 딜리트 키를 누른다면 에디터는 커서 오른쪽의 문자를 즉시 지울 것이다. 이를 눈치챈 일부 팀은 텍스트 클래스에 이러한 특정 기능을 지원하는 메서드를 추가했다: `void backspace(Cursor cursor)`, `void delete(Cursor cursor)`.

이 메서드들은 커서 위치를 인자로 받는다. `Cursor`는 커서의 위치를 의미한다. 에디터는 선택한 부분을 복사하거나 삭제할 수 있도록 셀렉션도 제공해야 한다. 학생들은 이를 `Selection` 클래스로 정의하고, 삭제 동작을 위해 이 클래스의 객체를 텍스트 클래스로 넘겼다: `void deleteSelection(Selection selection)`.

학생들은 아마 텍스트 클래스의 메서드를 사용자에게 보여지는 기능에 대응시키면 유저 인터페이스 구현이 쉬워진다고 생각했을 것이다. 하지만 현실에서 이러한 특수화는 유저 인터페이스 코드에 작은 이익을 줄 뿐이며, 개발자에게 높은 인지부하를 일으키게 된다. 결국 텍스트 클래스는 수많은 얕은 메서드를 갖게 되며, 각 메서드는 오로지 하나의 유저 인터페이스 동작에만 알맞다. `delete`와 같은 메서드들은 한 곳에서만 호출된다. 결과적으로 개발자는 텍스트 클래스에 있는 수많은 메서드를 익혀야 한다.
