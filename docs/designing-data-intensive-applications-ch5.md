# 복제

* 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미:
  * 데이터와 사용자의 거리를 지리적으로 가깝게 만들어 지연 시간을 줄인다.
  * 시스템 일부에 장애가 발생해도 지속적으로 동작할 수 있게 만들어 가용성을 높인다.
  * 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 높인다.
* 복제된 데이터가 시간이 지나도 변경되지 않는다면 문제가 없다:
  * 복제의 모든 어려움은 복제된 데이터의 변경 처리에 있다.
  * 거의 모든 분산 데이터베이스가 단일 리더, 다중 리더, 리더 없는 복제 알고리즘 중 하나를 사용한다.

## 리더와 팔로워

* 데이터베이스의 복사본을 저장하는 각 노드를 레플리카(replica)라고 한다.
* 복제 서버가 동일한 데이터를 유지하려면 모든 쓰기 질의가 모든 복제 서버에서 처리되어야 한다.
* 데이터 일관성 문제에 대한 일반적인 해결책은 리더 기반 복제다.
  ![](https://user-images.githubusercontent.com/6410412/67636527-db92bd80-f914-11e9-8ab4-51f9c86b29dd.png)
  * 레플리카 중 하나를 리더로 지정한다. 클라이언트가 데이터를 변경할 때는 리더에게 질의를 보낸다.
  * 또 다른 레플리카는 팔로워로 지정한다.  리더는 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그의 일부로 팔로워에게 전송한다.
  * 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 업데이트를 적용해 로컬 복사본을 갱신한다.
  * 클라이언트가 데이터를 읽을 때는 레플리카에게 질의할 수 있지만, 쓰기는 리더에게만 허용된다.

### 동기식 대 비동기식 복제

* 복제 시스템의 가장 중요한 세부 사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부다.
* 사용자가 프로필 사진을 업데이트하는 상황을 생각해보면:
  ![](https://user-images.githubusercontent.com/6410412/139523076-09a5691a-9e7f-4c2b-a9d2-4577dbf4b75b.png)
  * 팔로워 1: 동기식으로 동작한다. 리더는 팔로워 1이 쓰기를 수신했는지 확인해줄 때까지 기다린다.
  * 팔로워 2: 비동기식으로 동작한다. 리더는 메시지를 전송하지만 팔로워 2의 응답을 기다리지는 않는다.
* 동기식: 리더는 팔로워가 쓰기를 수신했는지 응답할 때까지 기다린다. 응답이 오면 사용자에게 성공을 응답하고, 다른 클라이언트에게 해당 쓰기를 보여준다.
  * 리더와 팔로워가 일관성있게 최신 데이터 복사본을 가진다고 보장할 수 있다.
  * 하지만 팔로워가 응답할 수 없는 상황에서는 쓰기 질의를 처리할 수 없다는 단점이 있다.
  * 반동기식: 보통 동기식 복제를 사용한다는 것은 팔로워 하나는 동기식으로 하고, 나머지는 비동기식으로 하는 것을 의미한다. 동기식 팔로워가 사용할 수 없게되면 비동기식 팔로워 중 하나가 동기식이 되어 데이터의 일관성을 보장한다.
* 비동기식: 리더가 팔로워에게 메시지를 전송하지만 응답을 기다리지 않는다.
  * 보통 리더 기반 복제는 완전히 비동기식으로 구성한다.
  * 리더에 문제가 생겨 복구할 수 없게 되면 팔로워에 아직 복제되지 않은 모든 쓰기가 유실된다.
  * 하지만 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있다는 장점이 있다.

### 노드 중단 처리

* 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소할 수 있어야 한다.
* 팔로워 장애: 각 팔로워는 리더의 데이터 변경 로그를 로컬 디스크에 보관한다. 팔로워가 중단되어 재시작하는 경우, 팔로워는 변경 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다. 그러면 리더와 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청해 처리할 수 있다.
* 리더 장애: 리더가 죽으면 팔로워 중 하나를 리더로 승격해야 하며, 클라이어트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하다. 또한 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비해야 한다. 이 과정을 장애 복구(failover)라 한다.
  1. 리더가 장애인지 판단한다: 장애의 원인은 너무 다양하기 때문에 대부분 타임아웃으로 장애를 판단한다.
  2. 새로운 리더를 선택한다: 보통 이전 리더의 최신 변경사항을 가진 레플리카가 리더로 선택된다.
  3. 새로운 리더를 사용하기 위해 시스템을 재설정한다.

### 복제 로그 구현

* 구문 기반 복제: 모든 쓰기 질의 구문을 로그에 기록한다. (MySQL 5.1 이전)
  ```
  mysql> create table test (text TEXT);
  mysql> insert into test values ("replication");
  mysql> select * from test;
  mysql> show binlog events
  ...
  Info: create table test (text TEXT)
  ...
  Info: insert into test values ("replication")
  ```
* 쓰기 전 로그 배송: WAL(write-ahead logging), 데이터를 변경하기에 앞서 로그에 기록한다. (PostgreSQL, Oracle 등)
* 로우 기반 복제: 변경된 로우 자체를 인코딩해 로그에 기록한다. (MySQL 5.1 이후 구문 기반 복제와 함께 사용)
* 트리거 기반 복제: 데이터가 변경되면 애플리케이션 코드를 실행하도록 트리거링. (Databus, Bucardo 등)

## 복제 지연 문제

* 리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만, 읽기 전용 질의는 어떤 복제 서버에서도 가능하다.
* 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 업데이트되지 않은 오래된 정보를 볼 수도 있다. 이런 불일치는 일시적이다. 데이터베이스에 쓰기를 멈추고 잠기 기다리면 팔로워는 리더를 따라잡게 된다. 이런 효과를 최종적 일관성이라고 한다.
* 지연이 매우 크면 불일치 문제는 이론적인 문제가 아니라 실제 문제가 된다. 이를 위해 쓰기 후 읽기 일관성(read-after-write consistency)과 단조 읽기(monotonic read)가 필요하다.

### 자신이 쓴 내용 읽기

* 비동기식 복제에서는 쓰기 직후 데이터를 조회한다면 새로운 데이터가 아직 레플리카에 반영되지 않았을 수 있다.
* 이때 쓰기 후 읽기 일관성이 필요하다:
  * 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. SNS라면 사용자가 자신의 프로필은 항상 리더에서 읽도록 할 수 있다.
  * 데이터의 갱신 후 1분 동안은 리더에서 모든 읽기를 수행한다.
* 동일한 사용자가 여러 디바이스를 사용한다면 디바이스 간 쓰기 후 읽기 일관성을 제공해야 한다:
  * 한 디바이스에서 수행 중인 코드는 다른 디바이스에서 발생한 변경을 모르기 때문에 메타데이터가 중앙집중식으로 관리되어야 한다.
  * 레플리카가 여러 데이터센터에 분산되어 있다면 서로 다른 디바이스의 연결을 동일한 데이터센터로 라우팅해야 한다.

### 단조 읽기

* 비동기식 팔로워가 겪는 또 다른 문제는 시간이 거꾸로 흐르는 현상이 발생한다는 것.
  ![](https://user-images.githubusercontent.com/6410412/139526112-50ae3192-9999-4d64-9d08-cad979066286.png)
* 단조 읽기는 이런 이상 현상이 발생하지 않음을 보장한다.
* 각 사용자의 읽기가 항상 동일한 레플리카에서 수행되게끔하면 단조 읽기를 달성할 수 있다.
* 가령 사용자 ID의 해시를 기반으로 복제 서버를 선택하면 한 사용자가 항상 같은 레플리카를 읽게 된다.

## References

* [오길원, "MariaDB Binlog을 이용한 변경사항 추적", 리디주식회사, 2017.](https://ridicorp.com/story/binlog-collector/)
