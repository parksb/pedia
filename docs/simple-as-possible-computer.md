# Simple-As-Possible 컴퓨터

- Alber P. Malvino가 <Digital Computer Electronics>에서 제시한 컴퓨터 모델.
- 단순한 SAP 컴퓨터 아키텍처를 통해 컴퓨터의 원리를 설명한다.

## Logic Circuits

- Inverter:
  - 두 개를 이어 붙이면 noninverting amplifier.
  - NOT하지 않으면 버퍼가 됨. 임피던스 레벨을 높이고 싶을 때.
- 그리고 OR, AND, ...
- 드 모르간 법칙:
  - NOR: $\overline{A + B} = \bar{A}\bar{B}$
  - NAND: $\overline{AB} = \bar{A} + \bar{B}$
  - 리팩토링할 때도 유용하다: `!A && !B`하지 말고 `!(A || B)`
- XOR: $A \oplus B = \bar{A}B + A\bar{B}$
  - 두 입력이 다를 때만 1을 출력하기 때문에 유용함.

## Arithmetic Circuits

- 이진수 덧셈하다가 carry가 있으면?
  - 십진수 덧셈할 때처럼 처리한다:
    ```
      1
      11100
    + 11010
    -------
     110110
    ```
  - 또 다른 예시:
    ```
      1111
       1101
    + 10111
    -------
     110110
    ```
- Half adder:
  - $\text{SUM} = A \oplus B$
  - $\text{CARRY} = AB$
  - 반가산기는 두 개 비트 덧셈밖에 못함.
- Full adder:
  - $\text{SUM} = A \oplus B \oplus C$
  - $\text{CARRY} = AB + AC + BC$
- Binary adder:
  - half adder 하나와 full adder를 이어 붙이면 된다.
- 부호를 어떻게 표현할 것인가?
  - 최상위 비트가 0이면 양수, 1이면 음수로 취급하면:
    - $+7_{10} = 0000\ 000\ 000\ 0111_2$
    - $-7_{10} = 1000\ 000\ 000\ 0111_2$
  - 이 방식은 너무 많은 아트웨어를 필요로 한다. 그 대안은..
  - 2의 보수를 취하는 방식:
    - invert한 다음 1을 더한다: $A^\prime = \bar{A} + 1$
    - 만약 $A = 0111$이라면, $A^\prime = 1001$
    - 원본으로 되돌리려면 다시 2의 보수를 취하면 된다: $A^{\prime\prime} = 0111$
    - 이제 양수와 음수를 아래와 같이 표현할 수 있음:
      - $A = +7_{10} = 0111_2$
      - $A^\prime = -7_{10} = 1001_2$
    - 8비트 컴퓨터에서 표현할 수 있는 최대, 최소는:
      - 최대: $0111\ 1111 = +127$
      - 최소: $1000\ 0001 = -127$
- 2's complement adder/subtractor:
  - 음수를 표현할 수 있으므로 덧셈과 같은 방식으로 뺄셈도 가능.
  - 만약 3에 -2를 더한다면:
    ```
      11
      0011
    + 1110
    ------
      0001
    ```
    - 마지막 CARRY 값은 버린다.
  - 뺄셈은 어떻게 할까? 3에서 2를 뺀다면:
    ```
      0011     0011
    - 0010   + 1101
    ------ = ------
      0001     0001
    ```
    - 뺄셈은 두 번째 피연산자에 2의 보수를 취하고 더하는 것과 같음.
    - 대상이 음수일 때도 마찬가지로 2의 보수를 취하고 더하면 된다.

## Flip-flops

- LOW 또는 HIGH 볼트로 하나의 비트를 저장할 수 있는 메모리 요소.
- RS flip-flop:
  - Q를 0으로 만드는 Reset과, 1로 만드는 Set 트리거를 입력받는 플립플롭.
  - 컴퓨터는 수많은 플립플롭을 사용하므로, 전체적인 동작을 제어하기 위해 클록을 사용한다.
  - 클록은 일정 주기로 신호를 보내는 수정 진동자. 올바른 시점에 플립플롭의 상태가 변할 수 있도록 만든다.
  - Clocked RS flip-flop: RS flip-flop 앞에 AND 게이트를 붙여서 클록이 LOW일 때 입력을 받지 않음.
- D flip-flop:
  - RS 플립플롭은 두 개의 데이터 입력을 받아야 하므로 불편함.
  - Unclocked DFF: 입력 D를 하나 두자. S에는 D를 그대로 입력하고, R에는 NOT D를 입력해주면 어떨까?
  - 클록까지 일체형으로 만든 소자가 DFF, D와 CLK를 입력으로 받는다.

## SAP-1

### Architecture

- PC(program counter): 0000부터 1111까지 카운트. 인스트럭션을 하나 fetch하면 카운트가 하나 늘어남. 따라서 각 fetch 사이클의 시작점에서 PC는 현재 인스트럭션의 주소를 가지고 있게 됨.
- MAR(memory address register): PC로부터 주소를 받아서 ROM에 전달.
- PROM: 프로그래밍 가능한 ROM.
- IR(instruction register): 버스로부터 ROM 인스트럭션 주소를 읽음. IR은 입력을 두 개의 부분으로 나누는데, 4개의 MSB opcode는 바로 CON에 전달되고, 4개의 LSB address는 버스로 보낸다.
- CON(control unit): 각 컴포넌트에 적절한 신호를 보내 제어하는 역할. IR로부터 받은 opcode를 보고 이에 따라 $C_PE_PL_ME_R\ L_IE_IL_AE_A\ S_UE_UL_UL_U$ 신호를 출력한다. 계산기와 컴퓨터를 구분짓는 결정적인 요소.
- A(accumulator): 연산의 중간 결과를 저장. 출력 중 하나는 ALU로, 다른 하나는 버스로 보낸다.
- ALU(arithmetic-logic unit)
- B(b register)
- OUT(output register)
- D(binary display)

### Machine cycle

컨트롤 유닛은 컴퓨터의 자동화된 연산의 핵심이다. 프로그램과 데이터가 메모리에 로드된 뒤, 시작 신호는 제어권을 CON에게 넘긴다. CON은 각 인스트럭션을 fetch, execute하는 컨트롤 워드를 출력한다. 각 인스트럭션이 fetch, execute되는 동안, 컴퓨터는 레지스터 내용이 변경되는 6단계의 machine cycle를 거친다. 사이클의 페이즈를 나타내기 위해서는 링 카운터를 사용한다.

링 카운터는 CON의 일부다. 링 카운터는 $T = T_5T_4T_3T_2T_1T_0$ 출력을 내며, 컴퓨터가 막 실행됐을 때 링 워드는 $T = 000001$가 된다. 다음 네거티브 클럭 엣지마다 링 워드는 $T = 000010$, $T = 000100$, $T = 001000$, ..., $T = 100000$과 같이 증가한다. 링 카운터는 다시 $T = 000001$로 돌아오며, 이 사이클을 반복한다. 각 링 워드는 하나의 머신 페이즈를 의미한다.

- Fetch cycle:
  - $T_0$는 주소 페이즈(address phase)로, 이때 PC의 주소가 MAR로 전달된다. CON은 주소 페이즈를 위해 $0110\ 0000\ 0000$을 출력한다.
  - $T_1$은 메모리 페이즈다. MAR로부터 주소를 받은 ROM은 해당하는 인스트럭션을 IR로 보낸다. 이때 CON의 출력은 $0001\ 1000\ 0000$.
  - $T_2$는 증가 페이즈(increment phase)다. PC가 1 증가하며, fetch 사이클의 마지막 단계다.
- Execution cycle: $T_3$부터 $T_5$는 execution 사이클이다. 인스트럭션에 따라 레지스터가 변경된다.
  - LDA 루틴: 만약 `LDA 9` 명령이 로드되면, $IR = 0000\ 1001$이 된다. 첫 실행 페이즈에서 IR은 4개의 MSB `0000`을 CON으로 보내고, 4개의 LSB `1001`은 버스를 통해 MAR로 로드된다. 두 번째 실행 페이즈에서는 MAR이 가리키는 ROM의 데이터가 A로 로드된다. 마지막 페이즈에는 CON이 모든 비트를 0으로 출력해 모든 레지스터가 비활성화된다.
  - ADD 루틴: `ADD B` 명령이 로드되면, $IR = 0001\ 1011$이 된다. 첫 실행 페이즈에서 opcode는 CON으로, 주소는 MAR로 보내진다. 두 번째 페이즈에서는 $E_R$과 $L_B$가 활성화되고, (CON에 인스트럭션에 따라 어떤 컨트롤 비트를 활성화할지 하드코드되어 있다.) ROM의 데이터는 B 레지스터로 전달된다. 마지막 페이즈에는 ALU가 A 레지스터에 B 레지스터의 값을 더하고, 그 결과를 A 레지스터에 저장한다.
