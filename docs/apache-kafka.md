# 아파치 카프카

- 카프카는 분산형 메시지 스트리밍 브로커로, 대용량의 실시간 이벤트를 처리할 수 있다.
- 링크드인의 시스템 아키텍처는 확장이 어렵고 혼란스러웠음:
  ![](https://hudi.blog/static/76d29083143d941844eb592d0c715ecf/ca1dc/before-kafka.png)
- 대규모 시스템은 유저 활동 로그(페이지뷰, 좋아요, 검색 쿼리 등), 운영 메트릭(서비스 콜 스택, 콜 레이턴시, 에러, CPU, 메모리 사용량 등)와 같은 방대한 로그 데이터를 만들어 낸다. 실제 데이터에 비해 로그 데이터는 그 양이 훨씬 많고 빠르게 증가하기 때문에 다루기 어렵다.
- 결과적으로 카프카를 중심으로 데이터가 흐르는 아키텍처를 구축했다:
  ![](https://hudi.blog/static/aa5daad0e5dc1f9db8d2a5abc95598b2/ca1dc/after-kafka.png)

## Architecture and Design

- 특정 유형의 메시지 스트림을 토픽(topic)이라고 부른다.
  - 하나의 토픽은 여러 개의 파티션으로 구성된다.
  - 메시지는 디스크에 파티션 단위로 저장되며, 파티션에 쌓이는 데이터는 정렬되어 있고, 불변하다.
- 프로듀서는 1개 이상의 토픽에 메시지를 발행하고, 발행된 메시지는 브로커(broker)라고 부르는 서버에 저장된다.
- 컨슈머는 1개 이상의 토픽을 구독할 수 있으며, 브로커에서 데이터를 pulling해 메시지를 소비한다.
  - RabbitMQ나 ActiveMQ와 달리 push 방식 대신 pull 방식으로 동작한다.
  - 이를 통해 컨슈머의 처리 능력에 따라 메시지를 소비할 수 있다.
- 만약 토픽에 소비할 메시지가 없다면, 토픽에 새 메시지가 발행될 때까지 메시지 스트림 이터레이터가 중단된다.
- 각 메시지는 오프셋으로 식별되며, 컨슈머가 메시지를 수신한 뒤에는 다음 메시지의 오프셋을 연산해 얻는다.
- 브로커에는 상태가 없다. 따라서 모든 컨슈머가 메시지를 수신했는지 알 수 없다.
- 브로커의 메시지는 일정 주기(보통 7일) 뒤 삭제된다.
  - [[redis-pub-sub]]{Redis Pub/Sub}의 경우 메시지가 디스크에 저장되지 않기 때문에 유실될 수 있다.
  - ActiveMQ와 RabbitMQ는 메시지를 디스크에 저장하는 옵션이 있지만, 기본적으로는 소비된 메시지를 삭제한다.

## Distributed Coordination

![](https://static.javatpoint.com/tutorial/kafka/images/apache-kafka-architecture3.png)

- 카프카에는 컨슈머 그룹이라는 개념이 있음. 각 컨슈머 그룹은 한 개 이상의 컨슈머로 구성됨.
  - 그룹 단위로 토픽을 구독할 수 있는데, 메시지는 그룹 내의 컨슈머 중 하나에게만 전달된다.
  - 같은 그룹에 속한 컨슈머들은 서로 다른 프로세스 또는 머신에서 동작할 수 있다.
- 카프카의 목표는 코디네이션 오버헤드를 최소화하면서 메시지를 분배하는 것.
  - 따라서 카프카에는 중앙집중식 마스터 노드가 없다. 대신 탈중앙화된 방식으로 동작한다.
  - 고가용성 컨센서스 서비스 주키퍼(Zookeeper)를 사용해 카프카 클러스터의 메타데이터를 관리한다.

## 같이 보기

- [[redis-pub-sub]]

## References

- https://kafka.apache.org/
- [Kafka: a Distributed Messaging System for Log Processing](https://notes.stephenholiday.com/Kafka.pdf)
