# Part 1. 데이터 시스템의 기초

* 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
  * [x] 데이터 시스템에 대한 생각
  * [x] 신뢰성
  * [x] 확장성
  * [x] 유지보수성
* 데이터 모델과 질의 언어
  * [x] 관계형 모델과 문서 모델
  * [x] 데이터를 위한 질의 언어
  * [x] 그래프형 데이터 모델
* 저장소와 검색
  * [x] 데이터베이스를 강력하게 만드는 데이터 구조
  * [x] 트랜잭션 처리나 분석?
  * [x] 칼럼 지향 저장소
* 부호화와 발전
  * [x] 데이터 부호화 형식
  * [x] 데이터플로 모드

## 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

* 오늘날 많은 애플리케이션은 계산 중심적이기 보다는 데이터 중심적이며, CPU 성능보다 데이터의 양, 복잡도, 변화가 더 큰 문제로 여겨진다.

### 신뢰성 (Reliability)

* 결함이 발생해도 시스템이 올바르게 동작함. 
* 하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 원하는 성능 수준에서 정확한 기능을 수행해야 한다.

### 확장성 (Scalability)

* 부하가 증가해도 좋은 성능을 유지함. 
* 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리하는 적절한 방법이 있어야 한다.
* 시스템이 현재 안정적이라고 해서 미래에도 안정적이라는 보장은 없다.

### 유지보수성 (Maintainability)

* 엔지니어와 운영팀의 삶을 개선함.
  * 운용성(Operability): 운영팀이 시스템을 원할하게 운영할 수 있도록.
  * 단순성(Simplicity): 복잡성을 줄여 엔지니어가 쉽게 시스템을 이해하도록.
  * 발전성(Evolvability): 엔지니어가 시스템을 쉽게 변경할 수 있도록.
* 시간이 지남에 따라 여러 사람이 시스템에서 작업을 할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있어야 한다.

## 데이터 모델과 질의 언어

* 데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영향을 미친다.

### 관계형 모델과 문서 모델

* 오늘날 가장 잘 알려진 데이터 모델은 관계형 모델을 기반으로한 SQL이다. 데이터는 관계로 구성되고, 각 관계는 순서 없는 튜플의 모음이다.

### 데이터를 위한 질의 언어

* SQL은 선언형 질의 언어인 반면 IMS와 코다실은 명령형 코드를 사용해 데이터베이스에 질의한다. 대부분의 프로그래밍 언어는 컴퓨터가 특정 순서로 특정 연산을 수행하게끔 지시하는 명령형 언어다. 선언형 질의 언어는 목표 달성을 위한 방법이 아니라 알고자 하는 데이터의 패턴을 지정하면 된다.
* 선언형 언어는 일반적으로 명령형 API보다 간결하다. 더 중요한 점은 데이터베이스 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 데이터베이스 시스템의 성능을 향상시킬 수 있다는 점이다.
* 맵리듀스(MapReduce) 질의는 여러 함수형 프로그래밍 언어에 있는 `map`과 `reduce` 함수를 기반으로 하는 모델이다. 몽고DB에서 제한적으로 지원하며, 선언형 질의 언어와 명령형 질의 API의 사이에 있다고 할 수 있다.
* 그래프형 데이터 모델은 다대다 관계를 구성하기에 효과적이다. 그래프는 정점과 간선으로 이뤄진다.

## 저장소와 검색

* 데이터베이스는 기본적으로 두 가지 작업을 수행한다: 
  * 데이터를 받으면 데이터를 저장한다.
  * 나중에 그 데이터를 요청하면 데이터를 제공한다.

### 데이터베이스를 강력하게 만드는 데이터 구조

* kvp로 구성되어 `set`과 `get`으로 데이터를 저장, 요청할 수 있는 데이터베이스를 생각해보자.
* 레코드가 방대하면 `get` 성능이 $`O(n)`$으로 좋지 않다. 이를 해결하기 위해 색인(Index)을 사용한다.

#### 해시 색인

* kvp 데이터를 색인하기 위해 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지할 수 있다.
* 램에 모든 키를 저장하면 고성능의 읽기, 쓰기가 가능하긴 하지만, 결국 디스크 공간이 부족해지는 문제가 있다.
* 특정 크기의 세그먼트로 데이터를 나누면 된다. 데이터가 특정 크기에 도달하면 기존 세그먼트를 닫고 새로운 세그먼트에 쓰기를 수행하는 컴팩션을 진행한다. 중복된 키를 버리고 각 키의 최신 값을 유지하기 때문에 공간을 줄일 수 있다.
* 하지만 해시 테이블 색인은 제한 사항이 있다:
  * 해시 테이블을 메모리에 저장해야 하므로 키가 너무 많으면 입출력이 많이 필요하고, 디스트가 가득차면 확장하는 비용이 든다. 또한 해시 충돌 해소를 위해 성가신 로직도 필요하다.
  * 해시 테이블은 범위 질의에 효율적이지 않다. 범위 질의를 수행하기 위해선 모든 개별 키를 조회해야 한다.

#### SS테이블과 LSM 트리

* SS테이블(Sorted String Table)은 일련의 kvp를 키로 정렬한 테이블이다.
* 키가 정렬되어 있으면 세그먼트 병합을 효율적으로 할 수 있고, 주변 키의 오프셋을 이용해 특정 키를 쉽게 찾을 수 있다.
* SS테이블은 데이터베이스가 고장나면 아직 디스크에 기록되지 않고 메모리의 멤테이블(Memtable)에 머물러있는 최신 데이터들이 손실된다. 이를 방지하기 위해서는 쓰기를 즉시 추가할 수 있는 분리된 로그를 디스크에 유지해야 한다.

#### 기타 색인 구조

* 색인 안에 값 저장: 키는 질의가 검색하는 대상이지만 값은 질의가 찾는 데이터거나 다른 곳의 데이터를 가리키는 참조가 될 수 있다. 후자의 경우 실제 데이터를 힙 파일(Heap file)에 저장하고, 각 색인은 힙 파일의 데이터 위치만 참조한다.
* 다중 칼럼 색인: 여러 개의 키에 색인을 적용할 수 있다. 가장 일반적인 유형은 결합 색인(Concatenated index)이다. 결합 색인은 하나의 칼럼에 다른 칼럼을 추가하는 방식으로 하나의 키에 여러 필드를 단순 결합한다.
* 전문 검색과 퍼지 색인: 유사한 키(오타 등)에 대해 검색하기 위해 퍼지 검색 기술을 사용한다. 전문 검색 엔진의 경우 특정 단어를 검색할 때 해당 단어의 동의어로 질의를 확장한다.

### 트랜잭션 처리나 분석?

* 트랜젝션 처리는 주기적으로 수행되는 일관 처리 작업과 달리 클라이언트가 지연 시간이 낮은 읽기와 쓰기를 가능하게 한다는 의미다.
* 처음에는 트랙잭션 처리와 분석 질의를 위해 동일한 데이터베이스를 사용했다. 이후엔 개별 데이터베이스에서 분석을 수행하며, 이 개별 데이터베이스를 데이터 웨어하우스라고 불렀다.

#### 데이터 웨어하우징

* 개별 데이터 웨어하우스를 사용하는 큰 장점은 분석 접근 패턴에 맞게 최적화할 수 있다는 점이다.
* 데이터 웨어하우스와 OLTP 데이터베이스는 둘 다 SQL 인터페이스를 지원하기 때문에 비슷해 보이지만, 내부는 서로 다른 질의 패턴에 맞게 최적화됐기 때문에 완전히 다르다.

#### 분석용 스키마: 별 모양 스키마와 논꽃송이 모양 스키마

* 분석 영역의 데이터 모델은 트랜잭션 처리 영역과 다르게 다양성이 훨씬 적다. 많은 데이터 웨어하우스가 별 모양 스키마로 알려진 정형화된 방식을 사용한다.
* 별 모양 스키마라는 이름은 테이블 관계가 시각화될 때 중앙에 있는 사실 테이블(Fact table)을 차원 테이블(Dimension table)로 둘러싸고 있는 모습에서 비롯됐다.
* 눈꽃송이 모양 스키마는 별 모양 스키마의 차원을 더욱 세분화하여 변형한 템플릿이다.

### 칼럼 지향 저장소

* 테이블의 데이터가 방대해지면 효율적으로 저장하고 질의하기 어려워진다.
* 칼럼 지향 저장소는 값을 로우 단위가 아닌 칼럼 단위로 저장하는 방식이다. 칼럼 지향 저장소 배치는 각 칼럼에 포함된 로우가 모두 같은 순서인 점에 의존한다.
* 데이터를 압축하면 데이터 처리량을 더 줄일 수 있으며, 데이터 웨어하우스에서 특히 효과적인 방법은 비트맵 부호화다. 

## 부호화와 발전

* 애플리케이션은 시간이 지남에 따라 변한다.
* 데이터 타입이나 스키마가 변경될 때 애플리케이션 코드 변경이 발생한다. 시스템이 원할하게 실행되게 하려면 양방향으로 하위 호환성을 유지해야 한다.

### 데이터 부호화 형식

* 데이터를 파일에 쓰거나 네트워크로 전송하려면 바이트열 형태로 부호화해야 한다. 포인터는 다른 프로세스가 이해할 수 없으므로 바이트열은 보통 메모리에서 사용하는 데이터 구조와는 상당히 다르다.
* 인메모리 표현에서 바이트열로의 전환을 부호화, 직렬화, 마샬링이라고 한다. 그 반대를 복호화, 파싱, 역직렬화, 언마샬링라고 한다.
* 프로그래밍 언어가 내부적으로 지원하는 부호화 형식은 심각한 문제점이 많다:
  * 다른 언어에서 데이터를 읽기 어렵다.
  * 동일한 객체 유형의 데이터를 복호화하려면 임의의 클래스를 인스턴스화할 수 있어야 하는데, 이는 보안 문제가 될 수 있다.
  * 데이터 버전 관리와 효율성을 부차적 문제로 여기게 된다.

#### JSON과 XML, 이진 변형

* JSON과 XML은 많은 언어에서 읽고 쓸 수 있는 표준화된 부호화 형식이다.
* JSON, XML, CSV는 어느 정도 사람이 읽을 수 있다. 아래와 같은 결점이 있기는 하지만 다양한 용도에 사용하기 충분하다.
  * XML, CSV는 수와 숫자로 이뤄진 문자열을 구분할 수 없다. JSON은 문자열과 수를 구분하지만 정수와 부동소수점 수를 구분하지 않는다.
  * JSON과 XML은 유니코드 문자열을 잘 이애하지만, 이진 문자열(부호화가 없는 바이트열)을 지원하지 않는다.
* 이진 형식은 다른 부호화 형식에 비해 작고 효율적이다.
* 사람들이 동의만 한다면 얼마나 읽기 쉽고 효율적인 형식인지는 대개 중요하지 않다. 무엇이든 다른 조직의 동의를 얻는 어려움은 대부분의 다른 문제보다 더 크다.

#### 스리프트와 프로토콜 버퍼

* 아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers)는 같은 원리를 기반으로 한 이진 부호화 라이브러리다.
* 스리프트와 프로토콜 버퍼 둘 다 부호화할 데이터를 위한 스키마가 필요하다.
* 새로운 버전의 스키마에 기본값이 없는 필드를 추가하면 새로운 읽기는 예전 쓰기가 기록한 데이터를 읽을 수 없어 하휘호환성이 깨진다.
* 기본값이 없는 필드를 삭제하면 예전 읽기는 새로운 쓰기가 기록한 데이터를 읽을 수 없어 상위호환성이 깨진다.

### 데이터플로 모드

* 데이터플로는 매우 추상적인 개념이며, 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 아주 많다.
* 네트워크를 통해 통신해야 하는 프로세스가 있을 때는 일반적으로 클라이언트와 서버를 배치한다.
* 서버 자체가 다른 서비스의 클라이언트가 되기도 한다. 이런 접근 방식은 대용량 애플리케이션 기능 영역을 소규모 서비스로 나누는 데 사용한다.
  * 이런 개발 방식을 전통적으로 서비스 지향 설계(Service-Oriented Architecture, SOA)라고 불렀다.
  * SOA를 개선한 것이 마이크로서비스 설계(MicroService Architecture, MSA)다.
* 웹 서비스에서 대중적인 두 가지 방법은 REST와 SOAP이다.
  * REST는 프로토콜이 아니라 HTTP의 원칙을 토대로 한 설계 철학이다.
  * SOAP은 네트워크 API 요청을 위한 XML 기반 프로토콜이다.
* 원격 프로시저 호출(Remote Procedure Call, RPC)는 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수를 호출하는 듯 사용할 수 있도록 해준다.
* RPC는 편리한 것 같지만 근본적인 결함이 있다:
  * 로컬 함수 호출은 결과를 반환하거나, 반환하지 않거나, 예외를 일으킬 수 있다. 반면 네트워크 요청으로 타임아웃이 일어나면 무슨 일이 일어났는지 알기 어렵다.
  * 실패한 네트워크 요청을 다시 시도할 때 요청이 실제로는 처리되고, 응답만 유실될 수 있다.
  * 네트워크 요청은 함수 호출보다 훨씬 느리다. 네트워크가 혼잡하면 같은 작업에도 시간이 더 걸릴 수 있다.
  * 로컬 함수와 다르게 네트워크 요청을 위해서는 부호화가 필요하다.
