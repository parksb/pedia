# Flux: Multi-Surface Computing in Android

## 1st Pass

> 1. 제목, 초록, 서론을 주의깊게 읽는다.
> 1. 각 대문단과 소문단의 머릿말을 읽는다. 다른 내용은 무시한다.
> 1. 수학적 내용이 있다면, 내용을 훑으며 이론적 기반을 살펴본다.
> 1. 결론을 읽는다.
> 1. 참고문헌을 훑어보고, 이미 읽은 문헌이 있는지 체크한다.

- 기존 멀티 서피스 앱의 한계:
  - 스크린캐스팅: single master 장치의 컴퓨팅 파워와 배터리에 의존.
  - 클라우드 backing: disconnected operation과 신뢰할 수 없는 클라우드 제공자.
- 어떤 앱이든 다른 기기로 마이그레이션할 수 있는 프레임워크, Flux를 제안한다.
- 보통 앱들이 state를 저장하지는 않으므로 다른 기기로 마이그레이션하는게 쉽지 않음.
- 심지어 기기가 다양하기 때문에 마이그레이션이 더 어려움.
- heterogeneity는 두 가지 방식으로 residual dependencies 또는 원본 시스템의 상태를 복잡하게 만든다:
  - 앱은 app-specific, device-specific한 상태를 가지는 시스템 서비스와 상호작용한다:
    - 하지만 앱과 함께 공유 시스템 서비스를 마이그레이션하거나, app-specific한 상태를 추출할 수 없음.
    - 다른 기기로 앱을 마이그레이션하면 device-specific한 상태로 인해 앱이 제대로 동작하지 않는다.
  - 실행 중인 앱은 시스템에서 쉽게 접근할 수 없는 상태를 가진다.
- Flux는 Selective Record/Adaptive Replay, Checkpoint/Restore In Android(CRIA) 매커니즘으로 해결:
  - Selective Record: 마이그레이션 이후 안드로이드 서비스의 정합성을 보장한다.
  - Adaptive Replay: 기록된 앱이 재개될 때 호출된다.
  - CRIA: 앱의 유저 레벨과 OS 레벨 상태를 체크포인트하고, 원격 기기에서 복원한다.

## 2nd Pass

> 1. 주의 깊게 논문을 읽는다. 단, 증명과 같은 상세한 내용은 무시한다.
> 1. 논문을 읽으면서 키 포인트를 메모하거나, 여백에 코멘트를 적어두면 도움이 된다.
> 1. 논문에 있는 도표나 다이어그램, 삽화를 유심히 본다. 특히 그래프는 자세히 확인한다.
> 1. 이해하지 못한 용어나 저자에게 물어보고 싶은 질문을 메모한다.
> 1. 나중에 읽기 위해 관련된 참고문헌 중 읽지 않은 것들을 표시해 둔다.

### Key points

- 앱이 설치된 디바이스를 home이라고 하자. 사용자는 home의 앱을 guest로 마이그레이트할 수 있다.
- 마이그레이션은 Pairing, Execution, Migration Out, Migration In 페이즈를 거친다:
  - Pairing: 마이그레이션 전에 home의 코어 프레임워크/라이브러리를 guest를 동기화하는 페어링 절차가 이뤄진다. 여기에서는 rsync로 두 디바이스의 파일을 동기화했다. 또한 설치 전에 guest에 APK의 메타데이터를 보내 앱의 퍼미션과 컴포넌트를 알 수 있게 한다.
  - App Execution: 바인더의 IPC 매커니즘을 통해 시스템 서비스와 앱의 인터랙션을 선택적으로 기록한다. 기록된 로그는 마이그레이션 이후 시스템 서비스 상태를 복원할 때 사용한다. 따라서 서비스를 마이그레이션할 필요가 없다.
  - Migration Out: 사용자가 두 손가락으로 스와이핑하면 마이그레이션을 시작한다. 먼저 디바이스의 상태를 최대한 해제하고, 앱을 백그라운드로 보내 서피스를 자유롭게 그릴 수 있도록 한다. 그리고 low-memory 상태를 트리거해 그래픽 관련 리소스를 해제한다. 이어서 Flux는 앱의 프로세스를 체크포인트한다. 이때 Binder IPC 상태도 체크포인트의 일부로 저장한다. 체크포인트는 앱의 데이터 디렉토리와 함께 guest에게 보내진다.
  - Migration In: 페어링할 때 만들어진 래퍼 앱을 이용해 앱의 체크포인트를 복원한다.
- Selective Record/AdaptiveReplay:
  - 시스템 서비스는 여러 앱이 공통으로 사용하며, device-specific하게 구현되어 있기 때문에 마이그레이션할 수 없다.
  - Flux는 시스템 서비스의 app-specific state를 변경하는 모든 호출을 기록하고, guest에서 리플레이한다.
  - 하지만 문제가 있다:
    - 모든 서비스 호출을 기록하고 재생하면 문제가 발생한다. e.g., 이미 확인한 알림이 다시 발송되는 문제.
    - 모바일 기기는 리소스가 제한적이기 때문에 모든 호출을 리플레이하면 리소스가 낭비되고 시간이 오래 걸린다.
    - 기기간 서비스가 동일하지 않으면 사용할 수 없다.
  - 이러한 문제를 해결하기 위해 Flux는 selective record/adaptive replay를 한다:
    - 현재 app-specific state와 관련된 호출만 선택적으로 기록하고 리플레이한다.
    - Flux는 프레임워크 개발자가 사1용할 수 있는 데코레이터를 제공한다. 데코레이터는 어떤 콜이 기록되어야 하는지, 시스템의 현재 상태에 어떻게 영향을 미치는지 구분해준다.
    - 앱이 마이그레이션되면 리플레이를 한다.
- CRIA:
  - 앱 프로세스 마이그레이션을 위해 Flux는 전통적인 checkpoint-restart 매커니즘을 확장한다.
  - CRIA는 앱의 코어 상태를 저장하고, 다른 디바이스에서 복원하는 것.
  - 네 가지 종류의 앱 상태가 있다:
    - Process:
    - Device
    - Filesystem
    - Network

### Questions

### References

## 3rd Pass

### Strength

### Weakness
